#!/usr/bin/env python3

"""
CAPTURA ROBUSTA DE TRADINGVIEW - Con manejo de errores y recargas
"""

import time
import base64
import logging
from selenium import webdriver
from selenium.webdriver.safari.options import Options as SafariOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException

logger = logging.getLogger(__name__)

class RobustTradingViewCapture:
    """Capturador robusto con manejo de errores y reintentos."""
    
    def __init__(self):
        self.driver = None
        self.max_retries = 3
        self._setup_driver()
    
    def _setup_driver(self):
        """Configurar Safari con configuraciones anti-detecci√≥n."""
        try:
            safari_options = SafariOptions()
            
            self.driver = webdriver.Safari(options=safari_options)
            
            # Configurar ventana y comportamiento m√°s natural
            self.driver.set_window_size(1920, 1080)
            self.driver.implicitly_wait(10)
            
            # Configurar user agent m√°s natural
            self.driver.execute_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => undefined,
                });
            """)
            
            print("‚úÖ Safari WebDriver configurado con protecciones anti-detecci√≥n")
            
        except Exception as e:
            print(f"‚ùå Error configurando driver: {e}")
            self.driver = None
    
    def _reload_page_if_needed(self):
        """Detectar si la p√°gina necesita recarga y hacerlo."""
        try:
            # Verificar si hay errores comunes que requieren recarga
            error_indicators = [
                "blocked",
                "error",
                "retry",
                "refresh",
                "reload",
                "try again"
            ]
            
            page_text = self.driver.find_element(By.TAG_NAME, "body").text.lower()
            
            for indicator in error_indicators:
                if indicator in page_text:
                    print(f"‚ö†Ô∏è Detectado problema en p√°gina: {indicator}")
                    print("üîÑ Recargando p√°gina...")
                    self.driver.refresh()
                    time.sleep(5)
                    return True
            
            return False
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error verificando p√°gina: {e}")
            return False
    
    def _wait_for_page_load(self):
        """Esperar a que la p√°gina cargue completamente."""
        try:
            # Esperar a que el estado sea 'complete'
            wait = WebDriverWait(self.driver, 30)
            wait.until(lambda driver: driver.execute_script("return document.readyState") == "complete")
            
            # Esperar un poco m√°s para JavaScript
            time.sleep(3)
            
            # Verificar si necesita recarga
            if self._reload_page_if_needed():
                # Si recargamos, esperar de nuevo
                wait.until(lambda driver: driver.execute_script("return document.readyState") == "complete")
                time.sleep(5)
            
            return True
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error esperando carga: {e}")
            return False
    
    def _handle_popups_and_overlays(self):
        """Cerrar popups y overlays que pueden aparecer."""
        try:
            # Lista de selectores para cerrar popups
            close_selectors = [
                "[data-name='close']",
                ".tv-dialog__close",
                ".js-dialog__close",
                "[aria-label='Close']",
                ".close-button",
                "[data-dialog-name] .close",
                ".tv-button--ghost",
                ".tv-screener-popup__close"
            ]
            
            closed_count = 0
            for selector in close_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed() and element.is_enabled():
                            self.driver.execute_script("arguments[0].click();", element)
                            closed_count += 1
                            time.sleep(1)
                except Exception:
                    continue
            
            if closed_count > 0:
                print(f"üö™ Cerrados {closed_count} popups/overlays")
            
            # Tambi√©n intentar presionar ESC para cerrar modales
            try:
                from selenium.webdriver.common.keys import Keys
                self.driver.find_element(By.TAG_NAME, "body").send_keys(Keys.ESCAPE)
                time.sleep(1)
            except:
                pass
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error manejando popups: {e}")
    
    def capture_with_retries(self, symbol: str = "SOLUSDT", timeframe: str = "1") -> str:
        """Capturar con reintentos autom√°ticos."""
        
        for attempt in range(self.max_retries):
            try:
                print(f"üîÑ Intento {attempt + 1}/{self.max_retries} para {symbol}")
                
                result = self._single_capture_attempt(symbol, timeframe)
                
                if result:
                    print(f"‚úÖ Captura exitosa en intento {attempt + 1}")
                    return result
                else:
                    print(f"‚ùå Fall√≥ intento {attempt + 1}")
                    if attempt < self.max_retries - 1:
                        print("‚è≥ Esperando antes del siguiente intento...")
                        time.sleep(5)
                        
            except Exception as e:
                print(f"‚ùå Error en intento {attempt + 1}: {e}")
                if attempt < self.max_retries - 1:
                    time.sleep(5)
        
        print("‚ùå Todos los intentos fallaron")
        return ""
    
    def _single_capture_attempt(self, symbol: str, timeframe: str) -> str:
        """Un solo intento de captura."""
        
        if not self.driver:
            return ""
        
        try:
            # URL con par√°metros espec√≠ficos para mejor carga
            url = f"https://www.tradingview.com/chart/?symbol=BINANCE%3A{symbol}&interval={timeframe}&hide_side_toolbar=1&hide_top_toolbar=1"
            
            print(f"üìä Navegando a TradingView: {symbol} ({timeframe}m)")
            
            self.driver.get(url)
            
            # Esperar carga completa
            if not self._wait_for_page_load():
                return ""
            
            print("‚è≥ Esperando que el gr√°fico se renderice...")
            time.sleep(8)
            
            # Manejar popups
            self._handle_popups_and_overlays()
            
            # Verificar que el gr√°fico est√© presente
            chart_present = self._verify_chart_presence()
            if not chart_present:
                print("‚ùå No se detect√≥ gr√°fico v√°lido")
                return ""
            
            # Limpiar interfaz para mejor captura
            self._clean_interface()
            
            # Esperar un momento final
            time.sleep(3)
            
            # Capturar screenshot
            print("üì∏ Capturando screenshot...")
            screenshot = self.driver.get_screenshot_as_png()
            
            # Guardar archivo local
            filename = f"tradingview_robust_{symbol}_{timeframe}m_{int(time.time())}.png"
            with open(filename, "wb") as f:
                f.write(screenshot)
            
            print(f"üíæ Guardado como: {filename}")
            
            # Convertir a base64
            img_b64 = base64.b64encode(screenshot).decode('utf-8')
            
            # Verificar que la imagen no est√© vac√≠a o corrupta
            if len(img_b64) < 1000:  # Imagen muy peque√±a = problema
                print("‚ùå Imagen capturada demasiado peque√±a")
                return ""
            
            print(f"‚úÖ Captura exitosa: {len(img_b64)} caracteres")
            return img_b64
            
        except Exception as e:
            print(f"‚ùå Error en captura: {e}")
            return ""
    
    def _verify_chart_presence(self) -> bool:
        """Verificar que hay un gr√°fico v√°lido en la p√°gina."""
        try:
            # Buscar m√∫ltiples indicadores de que el gr√°fico est√° presente
            chart_indicators = [
                ".tv-lightweight-charts",
                "[data-name='legend-source-item']",
                ".chart-container",
                ".chart-widget",
                "canvas[data-name='candle-series']",
                "canvas[width]"  # Canvas con ancho definido
            ]
            
            for selector in chart_indicators:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    if elements and any(el.is_displayed() for el in elements):
                        print(f"‚úÖ Gr√°fico detectado con: {selector}")
                        return True
                except:
                    continue
            
            print("‚ùå No se detect√≥ gr√°fico v√°lido")
            return False
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error verificando gr√°fico: {e}")
            return False
    
    def _clean_interface(self):
        """Limpiar la interfaz para mejor captura."""
        try:
            self.driver.execute_script("""
                // Ocultar elementos innecesarios
                const hideSelectors = [
                    '.tv-header',
                    '.tv-floating-toolbar',
                    '.tv-toast-logger',
                    '.tv-screener-popup',
                    '.tv-dialog',
                    '[data-name="header"]',
                    '.header-chart-panel',
                    '.tv-header__area--left',
                    '.tv-header__area--right',
                    '.js-rootresizer__contents > div:first-child',
                    '.layout__area--top'
                ];
                
                hideSelectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        if (el) el.style.display = 'none';
                    });
                });
                
                // Hacer que el √°rea del gr√°fico use toda la pantalla
                const chartArea = document.querySelector('.layout__area--center, .chart-container');
                if (chartArea) {
                    chartArea.style.position = 'fixed';
                    chartArea.style.top = '0';
                    chartArea.style.left = '0';
                    chartArea.style.width = '100vw';
                    chartArea.style.height = '100vh';
                    chartArea.style.zIndex = '9999';
                }
            """)
            
            print("üßπ Interfaz limpiada para captura")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error limpiando interfaz: {e}")
    
    def close(self):
        """Cerrar el navegador."""
        if self.driver:
            try:
                self.driver.quit()
                print("üîí Navegador cerrado")
            except:
                pass

def capture_tradingview_robust(symbol: str = "SOLUSDT", timeframe: str = "1") -> str:
    """Funci√≥n principal para captura robusta."""
    
    capturer = None
    try:
        capturer = RobustTradingViewCapture()
        
        if not capturer.driver:
            print("‚ùå No se pudo inicializar el driver")
            return ""
        
        return capturer.capture_with_retries(symbol, timeframe)
        
    except Exception as e:
        print(f"‚ùå Error general: {e}")
        return ""
        
    finally:
        if capturer:
            capturer.close()

if __name__ == "__main__":
    print("""
üõ°Ô∏è CAPTURA ROBUSTA DE TRADINGVIEW
=================================

Esta versi√≥n incluye:
‚úÖ Reintentos autom√°ticos
‚úÖ Detecci√≥n de errores de p√°gina  
‚úÖ Recarga autom√°tica si es necesario
‚úÖ Mejor manejo de popups
‚úÖ Verificaci√≥n de gr√°fico v√°lido
‚úÖ Limpieza de interfaz
‚úÖ Protecciones anti-detecci√≥n

¬°Probemos!
""")
    
    result = capture_tradingview_robust("SOLUSDT", "1")
    
    if result:
        print("\nüéâ ¬°CAPTURA ROBUSTA EXITOSA!")
        print("üìä Gr√°fico capturado con todas las protecciones")
        print("üöÄ Listo para integrar con el bot")
    else:
        print("\n‚ùå La captura robusta tambi√©n fall√≥")
        print("üí° Puede ser que TradingView est√© bloqueando el acceso")
